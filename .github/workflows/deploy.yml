name: Deploy Spring Boot App via Self-Hosted Runner

on:
  push:
    branches:
      - main

jobs:
  deploy:
    name: Deploy on Home Server
    runs-on: self-hosted

    env:
      COMPOSE_FILE: docker-compose-production.yml
      DEPLOY_DIR: /home/workshop/deploy/workshop_rest_api

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Initial step
        run: |
          echo "Actual directory:" && pwd
          echo "Folder content:" && ls -la

      - name: Prepare deploy directory
        run: |
          mkdir -p "${DEPLOY_DIR}"

      - name: Copy repo files to deploy dir
        run: |
          rsync -a --delete \
            --exclude '.git' \
            ./ "${DEPLOY_DIR}/"

      - name: Write .env with secrets
        working-directory: ${{ env.DEPLOY_DIR }}
        run: |
          set -e
          cat > .env <<'EOF'
          DB_NAME=${{ secrets.DB_NAME }}
          DB_USERNAME=${{ secrets.DB_USERNAME }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          HOST_BIND_IP=${{ secrets.HOST_BIND_IP }}
          LAN_CIDR=${{ secrets.LAN_CIDR }}
          GRAFANA_ADMIN_USER=${{ secrets.GRAFANA_ADMIN_USER }}
          GRAFANA_ADMIN_PASSWORD=${{ secrets.GRAFANA_ADMIN_PASSWORD }}
          EOF
          chmod 600 .env
          echo ".env created:"
          grep -E '^(DB_NAME|DB_USERNAME|HOST_BIND_IP|LAN_CIDR|GRAFANA_ADMIN_USER|GRAFANA_ADMIN_PASSWORD)=' .env || true

      - name: Build local images (no registry)
        working-directory: ${{ env.DEPLOY_DIR }}
        run: |
          docker compose -f "$COMPOSE_FILE" build workshop_spring_app

      - name: Up (recreate & remove orphans)
        working-directory: ${{ env.DEPLOY_DIR }}
        run: |
          docker compose -f "$COMPOSE_FILE" up -d --remove-orphans
          echo "===== SERVICES ====="
          docker compose -f "$COMPOSE_FILE" ps

      - name: Wait for workshop-api health
        run: |
          set -e
          ATTEMPTS=90
          SLEEP=5
          for i in $(seq 1 $ATTEMPTS); do
            STATUS=$(docker inspect --format='{{json .State.Health.Status}}' workshop-api 2>/dev/null | tr -d '"')
            echo "[$i/${ATTEMPTS}] workshop-api health: ${STATUS:-unknown}"
            if [ "$STATUS" = "healthy" ]; then
              echo "API is healthy ✅"
              exit 0
            fi
            sleep $SLEEP
          done
          echo "API did not become healthy in time ❌"
          echo "Recent logs:"
          docker logs --tail=200 workshop-api || true
          exit 1

      - name: Wait for observability stack
        run: |
          set -e
          echo "=== Verificando stack de observabilidade ==="
          
          # Verificar Loki (com retry)
          echo ">>> Verificando Loki..."
          ATTEMPTS=30
          SLEEP=5
          for i in $(seq 1 $ATTEMPTS); do
            LOKI_STATUS=$(curl -s http://localhost:3100/ready 2>/dev/null || echo "not ready")
            echo "[$i/${ATTEMPTS}] Loki: ${LOKI_STATUS}"
            if [ "$LOKI_STATUS" = "ready" ]; then
              echo "Loki is ready ✅"
              break
            fi
            if [ $i -eq $ATTEMPTS ]; then
              echo "Loki did not become ready in time ⚠️"
              docker logs loki --tail=50 || true
            fi
            sleep $SLEEP
          done
          
          # Verificar Grafana
          echo ""
          echo ">>> Verificando Grafana..."
          ATTEMPTS=30
          for i in $(seq 1 $ATTEMPTS); do
            GRAFANA_STATUS=$(curl -s http://localhost:3000/api/health 2>/dev/null | grep -o '"database":"ok"' || echo "not ready")
            echo "[$i/${ATTEMPTS}] Grafana: ${GRAFANA_STATUS}"
            if [ "$GRAFANA_STATUS" = '"database":"ok"' ]; then
              echo "Grafana is ready ✅"
              break
            fi
            if [ $i -eq $ATTEMPTS ]; then
              echo "Grafana did not become ready in time ⚠️"
              docker logs grafana --tail=50 || true
            fi
            sleep $SLEEP
          done
          
          # Verificar Promtail
          echo ""
          echo ">>> Verificando Promtail..."
          TARGETS=$(docker logs promtail 2>&1 | grep -c "added Docker target" || echo "0")
          echo "Promtail coletando $TARGETS containers"
          if [ "$TARGETS" -gt 0 ]; then
            echo "Promtail is collecting logs ✅"
          else
            echo "Promtail may not be collecting logs ⚠️"
            docker logs promtail --tail=30 || true
          fi
          
          # Verificar labels no Loki
          echo ""
          echo ">>> Verificando labels no Loki..."
          LABELS=$(curl -s http://localhost:3100/loki/api/v1/labels 2>/dev/null || echo "{}")
          if echo "$LABELS" | grep -q "container_name"; then
            echo "Labels OK ✅"
          else
            echo "Labels may not be available yet (normal on first deploy) ⚠️"
          fi
          
          echo ""
          echo "=== Stack de observabilidade verificada ==="

      - name: Bootstrap pgBackRest
        working-directory: ${{ env.DEPLOY_DIR }}
        run: |
          set -e

          PG_CID=$(docker compose -f "$COMPOSE_FILE" ps -q workshop_db)
          if [ -z "$PG_CID" ]; then
            echo "Postgres container not found"; exit 1
          fi

          echo ">>> Verificando stanza..."
          if docker exec -u postgres -e PGPASSWORD="${DB_PASSWORD}" "$PG_CID" pgbackrest --stanza=workshop --log-level-console=info check; then
            echo "stanza OK ✅"
          else
            echo "stanza ausente, criando..."
            docker exec -u postgres -e PGPASSWORD="${DB_PASSWORD}" "$PG_CID" pgbackrest --stanza=workshop --log-level-console=info stanza-create
            docker exec -u postgres -e PGPASSWORD="${DB_PASSWORD}" "$PG_CID" pgbackrest --stanza=workshop --log-level-console=info check
            echo "stanza criada e OK ✅"
          fi
          
          echo ">>> Estado dos backups:"
          docker exec -u postgres -e PGPASSWORD="${DB_PASSWORD}" "$PG_CID" pgbackrest info || true


      - name: Grant LAN access at pg_hba.conf
        working-directory: ${{ env.DEPLOY_DIR }}
        run: |
          set -e
          PG_CID=$(docker compose -f "$COMPOSE_FILE" ps -q workshop_db)
          if [ -z "$PG_CID" ]; then
            echo "Postgres container not found"; exit 1
          fi
          
          docker exec "$PG_CID" bash -lc '
            set -e
            FILE="$PGDATA/pg_hba.conf"
            LINE_LOCAL="local all '"${DB_USERNAME}"' md5"
            LINE_LAN="host all all '"${{ secrets.LAN_CIDR }}"' md5"
            grep -qF "$LINE_LAN" "$FILE" || echo "$LINE_LAN" >> "$FILE"
          '
          docker restart "$PG_CID"
          
          ATTEMPTS=60; SLEEP=3
          for i in $(seq 1 $ATTEMPTS); do
            STATUS=$(docker inspect --format='"'{{json .State.Health.Status}}'"' "$PG_CID" 2>/dev/null | tr -d '"')
            echo "[PG $i/$ATTEMPTS] health: ${STATUS:-unknown}"
            [ "$STATUS" = "healthy" ] && break
            sleep $SLEEP
          done

      - name: Containers status
        working-directory: ${{ env.DEPLOY_DIR }}
        run: |
          echo "===== CONTAINERS STATUS ====="
          docker compose -f "$COMPOSE_FILE" ps

      - name: Verify containers status and logs
        working-directory: ${{ env.DEPLOY_DIR }}
        run: |
          echo "===== CONTAINERS STATUS ====="
          docker compose -f "$COMPOSE_FILE" ps
          echo ""
          echo "===== CONTAINERS LOGS (Last 50) ====="
          for service in $(docker compose -f "$COMPOSE_FILE" ps --services); do
            echo ""
            echo "----- Logs: $service -----"
            docker compose -f "$COMPOSE_FILE" logs --tail=50 "$service" || true
          done
